Nitric's events service and API provides an intuitive approach to asynchronous messaging allowing services, functions and more to communicate via topics with event messages. While synchronous request/response communication is quite common, events provide a more reliable mechanism for communication in distributed and serverless systems, with the added benefit that services can be decoupled from each other through a [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) relationship.

The Nitric events API provides an interface to message-oriented middleware and message brokers such as AWS SNS & Google PubSub to facilitate low-latency, highly available, "at-least once" message delivery.

<img
  src="../assets/img/topics-overview.svg"
  height="334"
  alt="topic overview diagram"
/>

## Key concepts

- **Topics** are a named resource and target for publishing events. They typically define the _subject_ of the messages being published and subscribed.
- **Events** are a combination of metadata and a payload, produced by publishers and delivered to subscribers. Typically, these take the form of a JSON document with a standard format.
- **Publishers** produce events by sending them to a topic. Publishers are unaware of the topic's subscribers, providing strong decoupling.
- **Subscriptions** define the subscribers of a particular topic. Each subscription defines a subscriber, and the topic they subscribe to.
- **Subscribers** are consumers of events, typically in the form of a request that must handled.

## Create Topics

Topics are a resource defined in a stack file, such as `nitric.yaml`. At the root level of the stack file, add a `topics` key, which contains an array of topics. Topics will be automatically created and configured with defaults by the Nitric CLI when deploying to a cloud environment and emulated when running and testing locally.

```yaml
topics:
	# A Topic with default options
	my-topic: {}
```

During our preview release, no additional configuration is needed or available to create topics. All services and functions in your Nitric project will be configured with appropriate permissions to enable them to publish to all available topics. Future configuration will be introduced to define the list of permitted publishers (enabling least-privilege security by default), as well as configure more advanced topic features.

> Have a property or customization option that you need? Let us know on [GitHub](https://github.com/nitrictech/cli)

## Subscribing to Events

Resources that can subscribe to a topic, such as [services](./services) and [functions](./services-functions) provide a `triggers` property defining their triggers. Adding a new `topics` object under `triggers`, followed by the name of the topic(s) to subscribe to will set up a subscription between the resource and the topic(s). In the case of services, this causes the service to be invoked each time a new event is published to the topic, with the event being provided as the trigger payload. This is useful mechanism to use when one service needs to communicate with another in order to have the second service perform some work.

```yaml
services:
	my-subscribed-function:
		path: mysubscribedfunction
		runtime: function/python37
		triggers:
			topics:
				- my-first-topic
```

### At-Least-Once Delivery

Nitric events are delivered using cloud services that provide 'at least once delivery'. This means that typically every event is delivered at least once to each subscriber in the order it was received. However, the message ordering isn't guaranteed and messages may occasionally be delivered more than once.

To avoid reprocessing events that are delivered more than once your subscribers should typically be implemented using idempotent design patterns. Every Nitric event provides a unique `ID`, which is useful when implementing these patterns. Persisting the event id, alongside the results of processing the event, allows your application to check whether the id is already present before reprocessing duplicates.

> Event IDs are automatically generated by the [Nitric Membrane](./nitric-membrane) as v4 UUIDs. However, an ID can be provided when [publishing events](#event-ids) via the SDK if a custom implementation is needed.

### Supported Subscriber Resources

The following Nitric Stack resource support the `triggers` property, and the ability to subscribe to topics.

- [Services](./services)
- [Functions](./services-functions)

## Publish Events

Once a topic has been defined, services can publish to it using one of the Nitric SDKs. At minimum, a publish request requires the name of the topic to publish to, and the payload of the event to publish. An event's payload is typically a JSON string, however, the Nitric SDKs will often accept a 'plain old object' or map/dictionary value to simplify the code needed to publish events.

<CodeExamples>
<CodeExample lang={"node"}>

```typescript
// import the event client library
import { faas, events } from '@nitric/sdk';

faas.start(async (_: faas.NitricRequest<string>): Promise<string> => {
  // Create a new instance of the event client
  const eventsClient = events();

  // Publish an event to the topic 'my-topic'
  // Note: The event payload will be serialized automatically.
  await eventsClient.publish('my-topic', {
    payload: {
      amazing: 'thing happened!',
    },
  });

  return 'Successfully published message';
});
```

</CodeExample>
<CodeExample lang={"python"}>

```python
from nitric.api import Events

# Create a new Event Client with default settings
topic = Events().topic("my-topic")

payload = {"content": "of event"}

# Publish an event to the topic 'my-topic'
event = await topic.publish(Event(payload=payload))
```

</CodeExample>
<CodeExample lang={"java"}>

```java
package com.example;

import io.nitric.faas.Faas;
import io.nitric.faas.NitricEvent;
import io.nitric.faas.NitricFunction;
import io.nitric.faas.NitricResponse;
import io.nitric.faas.NitricResponse;
import io.nitric.api.event.EventClient;
import io.nitric.api.event.Event;
import java.util.Map;

public class MyFirstFunction implements NitricFunction {

	@Override
	public NitricResponse handle(NitricEvent event) {
			var eventClient = EventClient
				.newBuilder()
				.build();

			eventClient.publish("my-topic", Event.build(Map.of(
				"amazing", "thing happend!"
			)));

		return NitricResponse.build("Successfully published message");
	}

	public static void main(String[] args) {
		new Faas().start(new MyFirstFunction());
	}

}
```

</CodeExample>
<CodeExample lang={"go"}>

```go
package main

import (
	"github.com/nitrictech/go-sdk/faas"
	"github.com/nitrictech/go-sdk/api/events"
)

// NitricFunction - Handles individual function requests (http, events, etc.)
func NitricFunction(trigger *faas.NitricTrigger) (*faas.NitricResponse, error) {
	// Create a new events client
	ec, err := events.New()

	if err != nil {
		// ...handle the error
	}

	// Publish an event to my-topic
	ec.Topic("my-topic").Publish(&events.Event{
		PayloadType: "my-payload",
		Payload: map[string]interface{}{
			"amazing": "thing happened!",
		},
	}

	resp := trigger.DefaultResponse()
	resp.SetData([]byte("Successfully Published Message"))

	return resp, nil
}

func main() {
	faas.Start(NitricFunction)
}
```

</CodeExample>
<CodeExample lang={"php"}>

```php
namespace App\Function;

use Nitric\Faas\Faas;
use Nitric\Api\EventClient;


$handler = function(Request $request): Response
{
	// Create a new Event Client with default settings
	$eventClient = new EventClient();

	// Publish an event to the topic 'my-topic'
	// Note: The event payload will be serialized automatically.
	$eventClient->publish(
		topicName: "my-topic",
		payload: [
			"amazing" => "thing happened!",
		]);

	return new Response();
}

Faas::start($handler);
```

</CodeExample>

</CodeExamples>

### Event IDs

It's essential that every event can be uniquely identified so that subscribers can be idempotent. To assist with this, Nitric Events include an ID property which should contain the unique ID for that event. By default, the [Nitric Membrane](./nitric-membrane) will automatically generate this ID as a v4 UUID for every published event if it doesn't already contain an ID. Custom ID creation can be implemented by your code by simply providing this ID during publishing:

<CodeExamples>
<CodeExample lang={"node"}>

```typescript
// import the event client library
import { faas, events } from '@nitric/sdk';

faas.start(async (_: faas.NitricRequest<string>): Promise<string> => {
  const eventsClient = events();

  await eventsClient.publish('my-topic', {
    // Note: the event id should be generated using a process
    // that's guaranteed to be unique for practical purposes.
    id: 'unique-event-id',
    payload: {
      amazing: 'thing happened!',
    },
  });

  return 'Successfully published message';
});
```

</CodeExample>
<CodeExample lang={"python"}>

```python
from nitric.api import Events, Event

events = Events()

payload = {"content": "of event"}

# Note: the event id should be generated using a process that's guaranteed to be unique for practical purposes.
await events.topic("my-topic").publish(Event(id="unique-event-id", payload=payload))
```

</CodeExample>
<CodeExample lang={"java"}>

```java
package com.example;

import io.nitric.faas.Faas;
import io.nitric.faas.NitricEvent;
import io.nitric.faas.NitricFunction;
import io.nitric.faas.NitricResponse;
import io.nitric.faas.NitricResponse;
import io.nitric.api.event.EventClient;
import io.nitric.api.event.Event;
import java.util.Map;

public class MyFirstFunction implements NitricFunction {

	@Override
	public NitricResponse handle(NitricEvent event) {
			var eventClient = EventClient
				.newBuilder()
				.build();

            var event = Event
                .newBuilder()
                // Note: the event id should be generated using a process
                // that's guaranteed to be unique for practical purposes.
                .id('unique-event-id')
                .payload(
                    Map.of("amazing", "thing happend!")
                )
                .build()

			eventClient.publish("my-topic", event);

		return NitricResponse.build("Successfully published message");
	}

	public static void main(String[] args) {
		new Faas().start(new MyFirstFunction());
	}

}
```

</CodeExample>
<CodeExample lang={"go"}>

```go
package main

import (
	"github.com/nitrictech/go-sdk/faas"
	"github.com/nitrictech/go-sdk/events"
)

// NitricFunction - Handles individual function requests (http, events, etc.)
func NitricFunction(trigger *faas.NitricTrigger) (*faas.NitricResponse, error) {
	ec, err := events.New()

	if err != nil {
		// ...handle the error
	}

	_, err := ec.Topic("my-topic").Publish(&events.Event{
			ID: "unique-event-id",
			Payload: map[string]interface{}{
				"amazing": "thing happened!",
			},
	})

	msg := "Successfully Published Message"

	resp := trigger.DefaultResponse()
	resp.SetData([]byte("Successfully Published Message"))

	return resp, nil
}

func main() {
	faas.Start(NitricFunction)
}
```

</CodeExample>
<CodeExample lang={"php"}>

```php
namespace App\Function;

use Nitric\Faas\Faas;
use Nitric\Api\EventClient;


$handler = function(Request $request): Response
{
	$eventClient = new EventClient();

	$eventClient->publish(
		topicName: "my-topic",
		payload: [
			"amazing" => "thing happened!",
		]
        // Note: the event id should be generated using a process
        // that's guaranteed to be unique for practical purposes.
        id: "unique-event-id"
    );

	return new Response();
}

Faas::start($handler);
```

</CodeExample>
</CodeExamples>

#### Atomicity of Events

When implementing design patterns in order to ensure atomic state changes and event publishing, such as [Transactional Outbox](https://microservices.io/patterns/data/transactional-outbox.html), it's critical that any attempt to 'republish' an event due to a failure reuses the same event ID as any previous attempts. This ensures duplicate event deliveries won't contain mismatching IDs in the case that a previous attempt silently succeeded, while appearing to fail. In these cases we recommend generating your own event ID and storing it in the outbox record.
