## Introduction

This tutorial will help you get set up and running with your first integration with Stripe - a popular payments gateway.
The code snippets in this tutorial are lightly modified versions of the Stripe QuickStart featuring React and Go.

## Requirements

- Confirm that you have Node installed with the following command `node --version`
- It is also assumed that you have already installed the Nitric CLI. If not visit the [installation instructions](../installation.mdx).

> This tutorial provides examples in React & Go

## Getting started

This guide assumes you have the Nitric CLI installed, if not you can follow the [installation guide](/docs/installation).

You'll also want to setup your environment to run and test Nitric applications locally by installing prerequisite software. Use the `nitric doctor` command to check and automatically setup your machine.

If you’d like to deploy the results to a cloud environment _(optional)_, you’ll also need to setup your credentials and any other cloud specific configuration: [AWS](/docs/provider-aws), [GCP](/docs/provider-gcp), or [Azure](/docs/provider-azure).

## New project

We’ll start by creating a new project.

```bash
nitric make:project nitric-stripe-payments
```

```text
? Include an example service? function/golang15
? Name for the example function? nitric-stripe-payments
✔ Making Project nitric-stripe-payments
✔ Making Function payments
```

Next, open the project in your editor of choice. The scaffolded project should have the following structure:

```text
nitric-stripe-payments/
|
+--nitric.yaml
+--payments/
   |
   +--go.mod
   +--go.sum
   +--main.go
```

## Coding

Open the main.go file, and let's start coding -

We'll need the following import statements:

```golang15
package main

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/nitrictech/go-sdk/faas"
	stripe "github.com/stripe/stripe-go/v72"
	session "github.com/stripe/stripe-go/v72/checkout/session"
)
```

The sample react website that stripe provides sends data in the following format

```
{data={"product":"shirt","domain":{"href":"http://localhost:40497/","origin":"http://localhost:40497","protocol":"http:","host":"localhost:40497","hostname":"localhost","port":"40497","pathname":"/","search":"","hash":""}}}
```

This is a form-action POST with key "data" and a value with json content, so we'll have to do some marshalling.
Let's set up our structs to handle this data.

```golang15

// Structs which represent the incoming data
type Wrapper struct {
	Data ReturnData
}

type ReturnData struct {
	Product string
	Domain  DomainData
}

type DomainData struct {
	Href      string
	Origin    string
	Protocol  string
	Localhost string
	Hostname  string
	Port      string
	Pathname  string
	Search    string
	Hash      string
}
```

Now let's create a function "marshalData" which will get the data into a format we can work with.

```golang15
// Marshal the input data into a struct for ease of use
func marshalInput(trigger *faas.NitricTrigger, ed *Wrapper) {
	data, err := base64.StdEncoding.DecodeString(string(trigger.GetData()))
	if err != nil {
		data = trigger.GetData()
	}

	// Manually parse the data into a structured format which we can marshal
	fd, _ := url.QueryUnescape(string(data))
	fd = strings.Replace(fd, "=", ":", 1)
	fd = strings.Replace(fd, "data", "\"data\"", 1)
	fd = fmt.Sprintf("%v", "{"+fd+"}")

	// Marshal the data into the structs defined previously
	json.Unmarshal([]byte(fd), &ed)
}
```

Now let's modify the main function to include the stripe key.
You'll need to obtain this value from your stripe credentials page.

```golang15
func main() {
	stripe.Key = "sk_test_51JEyxJD8J1JQDwlM7ZiLB28L .... "
	faas.Start(NitricFunction)
}
```

Finally, let's modify or create the 'NitricFunction' function -

```golang15
// NitricFunction - Handles individual function requests (http, events, etc.)
func NitricFunction(trigger *faas.NitricTrigger) (*faas.NitricResponse, error) {

	// Add the code for the following steps here

}
```

First let's get the information out of the request which we need, this is product and domain information.

```golang15
	var inputData Wrapper
	marshalInput(trigger, &inputData)

	// Fetch the values from the BODY that we are interested in
	domain := fmt.Sprintf("%v", inputData.Data.Domain.Origin)
	product := fmt.Sprintf("%v", inputData.Data.Product)
```

Next let's set up the Stripe session

```
	params := &stripe.CheckoutSessionParams{
		PaymentMethodTypes: stripe.StringSlice([]string{
			"card",
		}),
		LineItems: []*stripe.CheckoutSessionLineItemParams{
			{
				PriceData: &stripe.CheckoutSessionLineItemPriceDataParams{
					Currency: stripe.String(string(stripe.CurrencyUSD)),
					ProductData: &stripe.CheckoutSessionLineItemPriceDataProductDataParams{
						//Name: stripe.String("T-shirt"),
						Name: stripe.String(product),
					},
					UnitAmount: stripe.Int64(2000),
				},
				Quantity: stripe.Int64(1),
			},
		},
		Mode:       stripe.String(string(stripe.CheckoutSessionModePayment)),
		SuccessURL: stripe.String(domain + "?success=true"),
		CancelURL:  stripe.String(domain + "?canceled=true"),
	}
	s, err := session.New(params)

```

If an error occurred, then let's send back a bad request status to the CheckoutSessionLineItemParams

```golang15
	response := trigger.DefaultResponse()
	if err != nil {
		response.GetContext().AsHttp().Status = http.StatusBadRequest
		return response, nil
	}
```

Otherwise we can set up the re-direct headers to send our user to the stripe payment gateway.

```golang15
	// Stripe relies on a redirect, so we are overwriting the headers to status 303 'see other'
	response.GetContext().AsHttp().Status = http.StatusSeeOther
	response.GetContext().AsHttp().Headers["Location"] = s.URL
	response.SetData([]byte(""))

	return response, nil
```

## Building the App

We will now look at creating a React app which will utilize our new `signup` service.

### Initialize a React app

Here we're going to be using the Stripe Quickstart, lightly modified to work with our payments service.
Let's start in our 'nitric-stripe-payments' folder where we will use npm to initialize a project.

```bash
npm init react-app payments-ui
cd payments-ui
```

Let's strip it down to the essentials, delete all files until the structure is as shown below:

```bash
payments-ui
|-- node_modules
|-- public
|   |-- index.html
|-- src
|   |-- App.js
|   |-- App.css
|   |-- index.js
|-- .gitignore
|-- package.json
|-- README.md
|-- tsconfig.json
|-- yarn.lock
```

Update index.html with -

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="A demo of a card payment on Stripe" />
    <title>Accept a card payment</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.
      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.
      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
```

Update App.js

```JavaScript
import React, { useState, useEffect } from "react";
import "./App.css";

const ProductDisplay = ({ data }) => (
  <section>
    <div className="product">
      <img
        src="https://i.imgur.com/EHyR2nP.png"
        alt="The cover of Stubborn Attachments"
      />
      <div className="description">
        <h3>Stubborn Attachments</h3>
        <h5>$20.00</h5>
      </div>
    </div>
    <form action="/create-checkout-session/" method="POST">
      <input type="hidden" id="data" name="data" value={data} />
      <button type="submit" id="checkout-button">
        Checkout
      </button>
    </form>
  </section>
);

const Message = ({ message }) => (
  <section>
    <p>{message}</p>
  </section>
);

function getData() {
  return JSON.stringify({
    product: 'shirt',
    domain: window.location
  });
}

export default function App() {
  const [message, setMessage] = useState("");

  useEffect(() => {

    // Check to see if this is a redirect back from Checkout
    const query = new URLSearchParams(window.location.search);

    if (query.get("success")) {
      setMessage("Order placed! You will receive an email confirmation.");
    }

    if (query.get("canceled")) {
      setMessage(
        "Order canceled -- continue to shop around and checkout when you're ready."
      );
    }
  }, []);

  return message ? (
    <Message message={message} />
  ) : (
    <ProductDisplay data={getData()} />
  );
}
```

Update index.js

```JavaScript
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";

ReactDOM.render(<App />, document.getElementById("root"));
```

Update App.css

```css
body {
  display: flex;
  justify-content: center;
  align-items: center;
  background: #242d60;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto',
    'Helvetica Neue', 'Ubuntu', sans-serif;
  height: 100vh;
  margin: 0;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
section {
  background: #ffffff;
  display: flex;
  flex-direction: column;
  width: 400px;
  height: 112px;
  border-radius: 6px;
  justify-content: space-between;
}
.product {
  display: flex;
}
.description {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
p {
  font-style: normal;
  font-weight: 500;
  font-size: 14px;
  line-height: 20px;
  letter-spacing: -0.154px;
  color: #242d60;
  height: 100%;
  width: 100%;
  padding: 0 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
}
img {
  border-radius: 6px;
  margin: 10px;
  width: 54px;
  height: 57px;
}
h3,
h5 {
  font-style: normal;
  font-weight: 500;
  font-size: 14px;
  line-height: 20px;
  letter-spacing: -0.154px;
  color: #242d60;
  margin: 0;
}
h5 {
  opacity: 0.5;
}
#checkout-button {
  height: 36px;
  background: #556cd6;
  color: white;
  width: 100%;
  font-size: 14px;
  border: 0;
  font-weight: 500;
  cursor: pointer;
  letter-spacing: 0.6;
  border-radius: 0 0 6px 6px;
  transition: all 0.2s ease;
  box-shadow: 0px 4px 5.5px 0px rgba(0, 0, 0, 0.07);
}
#checkout-button:hover {
  opacity: 0.8;
}
```

## Updating our yaml file

We'll need to add our new site to the Nitric yaml file and expose it via an entry point.

```yaml
name: stripe-quickstart
services:
  payments:
    path: payments
    runtime: function/golang15
sites:
  payments-ui:
    path: payments-ui
    assetPath: ./build
    buildScripts:
      - yarn build
entrypoints:
  payments:
    paths:
      /:
        type: site
        target: payments-ui
      /create-checkout-session/:
        type: service
        target: payments
```

This tells the Nitric CLI how to build the paths and where they point.

# Run the service

Time to run our project and see it in action!

```bash
nitric run
```

Take note of the entry point URL, paste it in a browser to test it out.
Stripe requires a credit card number of "4242 4242 4242 4242" to pass it's validation.

```bash
✔ Building Services
✔ Creating docker network
✔ Creating Volume: stripe-quickstart-vol-a3c87a31
✔ Running Services
✔ Starting API Gateways
✔ Starting Entrypoints
 Service  Port
 ──────── ─────
 payments 49156
 Entrypoint Url
 ────────── ──────────────────────
 payments   http://localhost:43555
 Running, press 'Q' to clean up and exit...
```

Once you're happy that everything is running correctly, you can deploy your API application to a cloud provider of your choice.

```bash
# Deploy to AWS
nitric deploy:aws

# Deploy to Google Cloud
nitric deploy:gcp

# Deploy to Azure
nitric deploy:azure
```
