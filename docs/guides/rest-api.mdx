## What we'll do

1. Create a new Nitric stack
2. Create [functions](/docs/intro/concepts/functions) to handle API operations
3. Create a [documents](/docs/reference/api/documents) collection to store data
4. Set up an [API gateway](/reference/project/api-gateways) and bind it to the functions
5. Get it all running locally for testing
6. Deploy to a cloud of your choice

| **Method** | **Route**          | **Description**                |
| ---------- | ------------------ | ------------------------------ |
| `GET`      | /orders            | List all orders                |
| `GET`      | /orders/{$orderId} | Get a specific order by its ID |
| `POST`     | /orders            | Create a new order             |

> This tutorial provides examples in TypeScript & Python

## Getting started

This tutorial assumes you have the Nitric CLI installed, if not you can follow the [installation guide](/docs/getting-started/installation).

You'll also want to setup your environment to run and test Nitric applications locally by installing prerequisite software. Use the `nitric doctor` command to check and automatically setup your machine.

If you’d like to deploy the results to a cloud environment _(optional)_, you’ll also need to setup your credentials and any other cloud specific configuration: [AWS](/docs/intro/cloud-providers/aws), [GCP](/docs/intro/cloud-providers/gcp), or [Azure](/docs/intro/cloud-providers/azure).

## New stack

We’ll start by creating a new stack for the REST API.

<CodeExamples 
	languages={[
	{
		label: "Node.js",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	}
	]}
	defaultLang="node"
><CodeExample lang="node">

<Box mt={4}>

You can create your Stack by running the `make:stack` command below:

</Box>

```bash
nitric make:stack my-rest-api
```

We love TypeScript, so let's choose `official/TypeScript Stack` as our template:

```text
? Stack template (Use arrow keys)
❯ official/TypeScript Stack
  official/Python Stack
  official/Java Stack
  official/Go Stack
```

Next, open the project in your editor of choice. The scaffolded project should have the following structure:

```text
my-rest-api/
|
+--nitric.yaml
+--api.yaml
+--package.json
+--.gitignore
+--common/
   |
   +--example.ts
   +--index.ts
   +--path.ts
+--functions/
   |
   +--create.ts
   +--list.ts
   +--read.ts
```

</CodeExample>
<CodeExample lang="python">

<Box mt={4}>

You can create your Stack by running the `make:stack` command below:

</Box>

```bash
nitric make:stack my-rest-api
```

We love TypeScript, so let's choose `official/TypeScript Stack` as our template:

```text
? Stack template (Use arrow keys)
  official/TypeScript Stack
❯ official/Python Stack
  official/Java Stack
  official/Go Stack
```

Next, open the project in your editor of choice. The scaffolded project should have the following structure:

```text
my-rest-api/
|
+--nitric.yaml
+--api.yaml
+--requirements.txt
+--.gitignore
+--common/
   |
   +--__init__.py
   +--example.py
+--functions/
   |
   +--__init__.py
   +--create.py
   +--list.py
   +--read.py
```

</CodeExample>
</CodeExamples>

The stack template already comes with a working API example, so we will use this example as a starter template for our orders API.

You can test the example stack with the `run` command.

```bash
nitric run
```

```bash
✔ Building Services
✔ Creating docker network
✔ Running Functions & Containers
✔ Starting API Gateways
✔ Starting Entrypoints
 Function Port
 ──────── ─────
 create   54054
 list     54055
 read     54056
 Api      Port
 ──────── ─────
 examples 49152
Running, press 'Q' to clean up and exit... -
```

Once running, use your browser to navigate to localhost on the port provided for the `examples` api, e.g. `http://localhost:49152/examples`. You should receive a success response from the api.

> The first time you run a stack it will take a moment longer to start while Docker image layers are downloaded and cached on your machine.

## Create orders

Next, let's turn the `create` function into the handler for `POST: /orders`, by having it add new orders to a document collection called `orders`. Since every new order will need a unique order id, for the purposes of this tutorial we'll generate a uuid to serve as the id.

<CodeExamples 
	languages={[
	{
		label: "Node.js",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	}
	]}
	defaultLang="node"
>
<CodeExample lang="node">

<Box mt={4}>

The stack already comes with the `uuidv4` dependency for id generation, so let's install our dependencies from the root of the stack:

</Box>

```bash
yarn install
```

Next, update the `create.ts` function to receive an "order create request", create the order and store it in the `orders` collection. For simplicity we will keep our Typescript typings in the same file, but these could be moved into the common directory later.

```typescript
// functions/create.ts

import { faas, documents } from '@nitric/sdk';
import { uuid } from 'uuidv4';

// Assume we receive a valid OrderCreate request object.
interface Order {
  id: string;
  dateOrdered: string;
  itemId: string;
  customerId: string;
}

// Requests to create a new order won't have an id or order date
interface CreateRequest extends Omit<Order, 'id' | 'dateOrdered'> {}

interface CreateResponse {
  message: string;
  orderId?: string;
}

// Start your function here
faas.start(
  async (
    request: faas.NitricTrigger<CreateRequest>
  ): Promise<faas.Response<CreateResponse>> => {
    const order = {
      ...request.dataAsObject(), // extract data from the request
      id: uuid(), // generate a new uuid
      dateOrdered: new Date().toJSON(),
    };

    const orders = documents().collection<Order>('orders');

    const response = request.defaultResponse() as faas.Response<CreateResponse>;
    try {
      // Write the new order document to the orders collection
      await orders.doc(order.id).set(order);
      response.data = { message: 'success', orderId: order.id };
    } catch {
      response.context.asHttp().status = 500;
      response.data = { message: 'failed to create order' };
    }

    return response;
  }
);
```

</CodeExample>
<CodeExample lang="python">

<Box mt={4}>

Update the `create.py` function so that it receives OrderRequests, then creates a new order, stores it in the `orders` collection and returns the new order's id.
We can re-use the generate_id method from the example stack to generate our id.

</Box>

```python
# functions/create.py

import dataclasses
from datetime import datetime
from dataclasses import dataclass, field
from typing import Union

from nitric.faas import start, Trigger, Response
from nitric.api import Documents
from common.example import generate_id


@dataclass(frozen=True)
class OrderRequest:
  itemId: str
  customerId: str
  id: str = field(default_factory=lambda: str(generate_id()))
  dateOrdered: str = field(default_factory=lambda: str(datetime.now()))


async def handler(request: Trigger) -> Union[dict, Response]:
  order = OrderRequest(**request.get_object())

  orders = Documents().collection('orders')

  try:
    await orders.doc(order.id).set(dataclasses.asdict(order))
    return {"message": "success", "orderId": order.id}
  except:
    response = request.default_response()
    response.context.as_http().status = 500
    response.data = {"message": "failed to create order"}
    return response


if __name__ == "__main__":
  start(handler)

```

</CodeExample>
</CodeExamples>

## Retrieve an order

Now that we can store new orders, let's update the read function for `GET: /orders/{$orderId}`, which will retrieve an order by its ID.

<CodeExamples 
	languages={[
	{
		label: "Node.js",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	}
	]}
	defaultLang="node"
><CodeExample lang="node">

<Box mt={4}>

First, update the `read.ts` file for this function so that it gets the orderId from the URL path parameters and uses it to retrieve and return the order document.

</Box>

```typescript
// functions/read.ts

import { faas, documents } from '@nitric/sdk';

faas.start(
  async (request: faas.NitricTrigger<void>): Promise<faas.Response<Object>> => {
    const orderId = request.context.asHttp().path.split('/')[2]; // use a parser in a real project.

    const orders = documents().collection('orders');

    const response = request.defaultResponse() as faas.Response<Object>;
    try {
      const order = await orders.doc(orderId).get();
      response.data = order;
    } catch {
      response.context.asHttp().status = 404;
      response.data = { message: 'order not found' };
    }
    return response;
  }
);
```

</CodeExample>
<CodeExample lang="python">

<Box mt={4}>

First, update the `read.py` file for this function so that it gets the orderId from the URL path parameters and uses it to retrieve and return the order document.

</Box>

```python
# functions/read.py

from typing import Union

from nitric.api import Documents
from nitric.faas import start, Trigger, Response


async def handler(request: Trigger) -> Union[dict, Response]:
  order_id = request.context.as_http().path.split("/")[2]  # use a parser in a real project.

  orders = Documents().collection("orders")

  try:
    order = await orders.doc(order_id).get()

    return {
      "id": order.id,
      "order": order.content,
    }
  except:
    response = request.default_response()
    response.context.as_http().status = 404
    response.data = {"message": f"order with id: {order_id} not found"}
    return response


if __name__ == "__main__":
  start(handler)

```

</CodeExample>
</CodeExamples>

## List all orders

Finally, we'll update the list function for `GET: /orders`, which will list every order.

<CodeExamples 
	languages={[
	{
		label: "Node.js",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	}
	]}
	defaultLang="node"
>
<CodeExample lang="node">

<Box mt={4}>

Update the `list.ts` file for the list function so it retrieves every order from the `orders` collection.

</Box>

```typescript
// functions/list.ts

import { faas, documents } from '@nitric/sdk';
import { FetchResponse } from '@nitric/sdk/lib/api/documents/query';

faas.start(
  async (request: faas.NitricTrigger<void>): Promise<faas.Response<Object>> => {
    const orders = documents().collection('orders');
    const results: any[] = [];
    const response = request.defaultResponse();
    let token: any = null;
    while (true) {
      try {
        const page = (await orders
          .query()
          .pagingFrom(token)
          .fetch()) as FetchResponse<any>;
        results.push(
          ...page.documents.map(({ id, content }) => ({
            id,
            content,
          }))
        );
        if (!page.pagingToken) {
          break;
        }
        token = page.pagingToken;
      } catch (e) {
        response.context.asHttp().status = 500;
        response.data = { message: e.stack };
      }
    }
    return response as faas.Response<Object>;
  }
);
```

</CodeExample>
<CodeExample lang="python">

<Box mt={4}>

Update the `list.py` file for the list function so it retrieves every order from the `orders` collection.

</Box>

```python
# functions/list.py

from nitric.api import Documents
from nitric.faas import start, Trigger, Response


async def handler(request: Trigger) -> list:
  orders = Documents().collection("orders")
  results = []
  token = None

  while True:
    page = await orders.query().page_from(token).fetch()
    results += [{"content": doc.content, "id": doc.id} for doc in page.documents]
    token = page.paging_token
    if not token:
        break
  return results


if __name__ == "__main__":
  start(handler)
```

</CodeExample>
</CodeExamples>

## Add the API Gateway

Now that we have functions to handle our API operations, we can add the API definition to our project. This will make the functions accessible and trigger them in response to specific requests to the API URL.

> Learn more: [API Gateways Documentation](/docs/reference/project/api-gateways)

Update your `api.yaml` file to the following:

```yaml
# Note: APIs are defined in OpenAPI Spec 3. The following is a basic example, but can be extended using the specification standards.
openapi: 3.0.0
info:
  version: 1.0.0
  title: Orders API
  description: Tutorial orders API
paths:
  /orders:
    get:
      operationId: list
      x-nitric-target:
        name: list
        type: function
      description: Retrieve all orders
      responses:
        '200':
          description: Successful response
    post:
      operationId: create
      x-nitric-target:
        name: create
        type: function
      description: Creates and persists new orders
      responses:
        '200':
          description: Successful response
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/OrderCreate'
  /orders/{orderId}:
    get:
      operationId: read
      parameters:
        - in: path
          name: orderId
          schema:
            type: string
          required: true
      x-nitric-target:
        name: read
        type: function
      description: Retrieve an existing order by its ID
      responses:
        '200':
          description: Successful response
components:
  schemas:
    OrderCreate:
      type: object
      properties:
        itemId:
          type: string
        customerId:
          type: string
```

Now lets add our `orders` collection and rename our API, update your `nitric.yaml` to the following:

<CodeExamples 
	languages={[
	{
		label: "Node.js",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	}
	]}
	defaultLang="node"
>
<CodeExample lang="node">

```yaml
name: my-rest-api
# Nitric functions
functions:
  create:
    handler: functions/create.ts
  read:
    handler: functions/read.ts
  list:
    handler: functions/list.ts
# Nitric collections
collections:
  orders: {}
# Nitric APIs
apis:
  orders: api.yaml
```

</CodeExample>
<CodeExample lang="python">

```yaml
name: my-rest-api
# Nitric functions
functions:
  create:
    handler: functions/create.py
  read:
    handler: functions/read.py
  list:
    handler: functions/list.py
# Nitric collections
collections:
  orders: {}
# Nitric APIs
apis:
  orders: api.yaml
```

</CodeExample>
</CodeExamples>

## Run it!

Now that you have an API defined and functions built to handle each of its methods, it's time to test it out locally before deploying to the cloud.

Try out your application with the `run` command:

```bash
nitric run
```

> _Note:_ In this case, `run` starts a container to act as an API gateway, as well as a container for each of the services.

Once it starts, the application will receive requests via the API port. You can use cURL, Postman or any other HTTP client to test the API.

```bash
# Create an order
curl -H "Content-Type: application/json" -X POST -d '{"itemId":"test-item","customerId": "test-customer"}' http://localhost:YOUR_API_PORT/orders

# Retrieve an order
curl http://localhost:YOUR_API_PORT/orders/YOUR_ORDER_ID

# List orders
curl http://localhost:YOUR_API_PORT/orders
```

## Deploy to the cloud

Once you're happy that everything is running correctly, you can deploy your API application to a cloud provider of your choice.

<Box
  sx={{
    mb: 2,
    px: 2,
    borderRadius: '4px',
    display: 'grid',
    gap: {
      md: 3,
    },
    gridTemplateColumns: 'repeat(3, 1fr)',
    backgroundColor: '#f4f4f4',
    '& > a': {
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'center',
      px: 1,
      my: {
        xs: 1,
        md: 2,
      },
      transition: 'all 0.3s ease-in',
      '&:hover, &:focus': {
        backgroundColor: '#ececec',
      },
    },
  }}
>
  <Link href="/docs/intro/cloud-providers/aws">
    <img src="/img/logos/aws.svg" noMargin priority height={50} />
  </Link>
  <Link href="/docs/intro/cloud-providers/gcp">
    <img src="/img/logos/gcp.svg" noMargin priority height={130} />
  </Link>
  <Link href="/docs/intro/cloud-providers/azure">
    <img src="/img/logos/azure.svg" noMargin priority height={40} />
  </Link>
</Box>
