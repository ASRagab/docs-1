Nitric Queues are designed to facilitate **_pull_** based workloads, where tasks are sent by producers and received by consumers. Both ends of the transaction are requests, i.e. the consumer asks the queue for more tasks, the queue doesn't push tasks to the consumers.
This flow is useful in situations such as batch processing or when consumers aren't always available.

<img
  height="134"
  src="../assets/img/queues-overview.svg"
  alt="queue overview diagram"
/>

## Key concepts

- **Queues** are a named target for `sending` and `receiving` `tasks`. They're typically named based on the _subject_ of the tasks they will contain or the intended recipient.
- **Tasks** are a combination of tasks metadata, a payload and when received a lease. Typically, a task payload will take the form of a JSON document.
- **Producers** produce tasks by sending them to queues. Unlike Event Publishers, Producers may be aware of the intended consumer of a tasks, since a queue can be intended for single Consumer.
- **Consumers** use receive requests to pull tasks from a queue. To ensure tasks aren't lost in the case of a failure, tasks are leased for a limited amount of time. Consumers must notify the queue that a tasks has been completed, otherwise it will requeue once the lease expires.

### Task format

Nitric uses named types for all messages to identify their intended purpose (e.g. tasks & events), a task is a message to be sent or received from a queue. Tasks typically define work to be done and are received and complete by services or functions. Task messages consist of payload, which is a custom object which defines the task, along with a limited set of metadata properties which assist in identifying tasks and ensuring they're processed correctly.

When using one of the Nitric SDKs, typically only the `payload` is required. This is usually a standard object or a map/dictionary in the programming language being used. In the majority of cases, objects can be passed into and received from the SDK methods without prior conversion or serialization. Over the wire a `Struct` or JSON document will be used as the serialized format for the payload.

| Property     | Type     | Description                                                                                                                                                                                                                                                                                                             |
| ------------ | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ID           | `String` | The unique for the task, no two task should have the same id. However, the same ID may be received by consumers more than once in the case that a lease expires before a task is complete.                                                                                                                              |
| Payload      | `Struct` | The task data payload. This is typically an Object or Map/Dictionary depending on the client language. Nitric SDKs will automatically convert objects to the required `Struct` format                                                                                                                                   |
| Payload Type | `String` | Payload Type is an optional property which provides a location to store a typehint string for the payload. E.g. `io.nitric.example.task`. This data may be used to assist with deserialization of the payload `Struct`.                                                                                                 |
| Lease ID     | `String` | `Read Only` Lease IDs are only present on tasks that have been received from a queue. Every request to receive a task will generate a unique lease id. This id is used when completing a task, extending a lease or releasing a task back to the queue. Only the latest lease id will be accepted for those operations. |

## Defining Queues

The first step before tasks can be sent or received is to define a queue. Queues are a resource defined in a Nitric Stack file, such as `nitric.yaml`. At the root level of the stack definition, there can be a `queues` key, which contains and array of queues.

The provider specific implementations for a queue are decided based on the best practices for implementing queue-like behavior in each environment.

> For specific detail on how queues are implemented for each provider see here.

```yaml
queues:
	# Create queues with default options
	my-queue: {}
	my-other-queue: {}
```

<!-- ### Syntax
To define a queue in your Nitric Stack, use the following syntax:

**_YAML_**

```yaml
- name: String
```

**_Properties_**

`name`

Defines the unique name of the queue, used in all future interactions with the queue via Nitric tooling and SDKs.

> **Note:** must contain only letters, numbers and dashes.

_Required:_ Yes

_Type:_ String -->

## Setup Producers

> Coming Soon: Capability to limit queue push capability to a subset of services

## Usage

Using one of the provided Nitric SDKs for your language is the easiest way to work with queues.

### Sending Tasks

Using one of the provided Nitric SDKs for your language is the easiest way to work with queues. First, start by importing the QueueClient.

<CodeExamples>
<CodeExample lang="node">

```typescript
import { Queueing } from '@nitric/sdk';

// Construct a new queue client
const queuesClient = Queueing();

// Publish a task to the queue
await queuesClient.queue('my-queue').send({
  payload: {
    example: 'payload',
  },
});
```

</CodeExample>
<CodeExample lang="python">

```python
from nitric.api import Queues, Task

# Construct a new queue client with default settings
queues = Queues()

payload = {"content": "of task"}

# Publish a task to a queue
queues.queue("my-queue").send(Task(payload=payload))
```

</CodeExample>

<CodeExample lang="java">

```java
package com.example;

import io.nitric.api.queue.Queues;
import io.nitric.api.queue.Task;
import java.util.Map;

...

var queue = Queues.queue("my-queue");
queue.send(
	Task.newBuilder()
		.id("1234")
		.payloads(Map.of("example", "payload")
		.build()
);

```

</CodeExample>
<CodeExample lang="go">

```go
import (
	"github.com/nitrictech/go-sdk/api/queues"
)

...

qc := queues.New()

ftasks, err := qc.Queue("my-queue").Send([]*queues.Task{
	&queues.Task{
		ID: "1234",
		PayloadType: "test-payload",
		Payload: map[string]interface{}{
			"example": "payload",
		},
	},
})

if err != nil {
	// handle error...
}

for _, ft := range ftasks {
	// enumerate tasks that failed to queue
}

```

</CodeExample>

<CodeExample lang="php">

```php
use Nitric\Api\Queues;
use Nitric\Api\Task;

$queues = new Queues();

$task = (new Task())
    ->setPayload([
        "example" => "payload"
    ]);

$queues->queue("my-queue")->send($task);
```

</CodeExample>

<CodeExample lang="c-sharp">

```csharp
using Nitric.Api.Faas;
using Nitric.Api.Queue

...

var queue = new Queues().Queue("my-queue")

var task = Task.NewBuilder()
	.Id("my-task")
	.Build();

queue.Send(task);
```

</CodeExample>

</CodeExamples>

### Receiving & Completing Tasks

To process tasks from a queue use a `QueueClient` to `receive` tasks. Since the process is asynchronous, the queue is unaware of whether the task was processed successfully. To ensure failed services don't result in lost tasks, tasks are not removed from a queue when they're received. Instead, tasks are hidden and receivers are granted a temporary `lease` for each task they receive. Once the task is complete, the receiver must make a second call to the queue to `complete` the task, which will remove it from the queue.

<CodeExamples 
	languages={[
	{
		label: "Node",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	},
	{
		label: "Java",
		value: "java"
	},
	{
		label: "Go",
		value: "go"
	},
	{
		label: "PHP",
		value: "php"
	},
	{
		label: "C#",
		value: "c-sharp"
	}
	]}
	defaultLang="node"
>
<CodeExample lang="node">

```typescript
import { Queueing } from '@nitric/sdk';

const queueClient = Queueing();

// Receive tasks from the queue
const tasks = await queueClient.queue('my-queue').receive();

tasks.map((task) => {
  // Work on a task...

  // Complete the task
  return task.complete();
});
```

</CodeExample>
<CodeExample lang="python">

```python
from nitric.api import Queues, Task

# Construct a new queue client with default settings
queue = Queues().queue("my-queue")

# Receive tasks from the queue
tasks = await queue.receive()
for task in tasks:
	// Work on a task...

	// Complete the task if it was processed successfully
	task.complete()
```

</CodeExample>

<CodeExample lang="java">

```java
package com.example;

import io.nitric.api.queue.Queues;
import io.nitric.api.queue.Task;
import java.util.Map;

...

// Construct a new queue client for the 'example' queue
var queue = Queues.queue("my-queue");

// Receive a list of tasks from the 'example' queue
List<Task> tasks = queue.receive(1);

for (Task task : tasks) {
	try {
		// process task here
		// processTask(task);

		task.Complete();
	} catch (Exception e) {
		// We don't need to requeue the task here
		// we can simply log the error and move on
		// the task will automatically requeue itself
	}
}
```

</CodeExample>
<CodeExample lang="go">

```go
import (
	"github.com/nitrictech/go-sdk/api/queues"
)

...

// Construct a new queue client with default settings
qc := queues.New()

// Receive tasks from the queue
tasks, err := qc.Queue("my-queue").Receive()

if err != nil {
	// handle error...
}

for _, task := range tasks {
	// process the task
	// complete the task
	err := task.Complete()
	if err != nil {
		// task failed to complete
	}
}
```

</CodeExample>

<CodeExample lang="php">

```php
use Nitric\Api\Queues;
use Nitric\Api\Task;

$queues = new Queues();

$tasks = $queues->queue("my-queue")->receive();

foreach($tasks as $task) {
	// process the task here...
	$task->complete();
}
```

</CodeExample>

<CodeExample lang="c-sharp">

```csharp
using Nitric.Api.Faas;
using Nitric.Api.Queue

...

var queue = new Queues().queue("my-queue");

var tasks = queue.Receive(1);

foreach (Task task in tasks) {
	// process tasks

	// Complete the task
	task.Complete();
}
```

</CodeExample>

</CodeExamples>
