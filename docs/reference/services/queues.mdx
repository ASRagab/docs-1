Nitric Queues are designed to facilitate **_pull_** based workloads, where tasks are sent by producers and received by consumers. Both ends of the transaction are requests, i.e. the consumer asks the queue for more tasks, the queue doesn't push tasks to the consumers.
This flow is useful in situations such as batch processing or when consumers aren't always available.

<img
  height="134"
  src="../assets/img/queues-overview.svg"
  alt="queue overview diagram"
/>

## Key concepts

- **Queues** are a named target for `sending` and `receiving` `tasks`. They're typically named based on the _subject_ of the tasks they will contain or the intended recipient.
- **Tasks** are a combination of tasks metadata, a payload and when received a lease. Typically, a task payload will take the form of a JSON document.
- **Producers** produce tasks by sending them to queues. Unlike Event Publishers, Producers may be aware of the intended consumer of a tasks, since a queue can be intended for single Consumer.
- **Consumers** use receive requests to pull tasks from a queue. To ensure tasks aren't lost in the case of a failure, tasks are leased for a limited amount of time. Consumers must notify the queue that a tasks has been completed, otherwise it will requeue once the lease expires.

### Task format

Nitric uses named types for all messages to identify their intended purpose (e.g. tasks & events), a task is a message to be sent or received from a queue. Tasks typically define work to be done and are received and complete by services or functions. Task messages consist of payload, which is a custom object which defines the task, along with a limited set of metadata properties which assist in identifying tasks and ensuring they're processed correctly.

When using one of the Nitric SDKs, typically only the `payload` is required. This is usually a standard object or a map/dictionary in the programming language being used. In the majority of cases, objects can be passed into and received from the SDK methods without prior conversion or serialization. Over the wire a `Struct` or JSON document will be used as the serialized format for the payload.

| Property     | Type     | Description                                                                                                                                                                                                                                                                                                             |
| ------------ | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ID           | `String` | The unique for the task, no two task should have the same id. However, the same ID may be received by consumers more than once in the case that a lease expires before a task is complete.                                                                                                                              |
| Payload      | `Struct` | The task data payload. This is typically an Object or Map/Dictionary depending on the client language. Nitric SDKs will automatically convert objects to the required `Struct` format                                                                                                                                   |
| Payload Type | `String` | Payload Type is an optional property which provides a location to store a typehint string for the payload. E.g. `io.nitric.example.task`. This data may be used to assist with deserialization of the payload `Struct`.                                                                                                 |
| Lease ID     | `String` | `Read Only` Lease IDs are only present on tasks that have been received from a queue. Every request to receive a task will generate a unique lease id. This id is used when completing a task, extending a lease or releasing a task back to the queue. Only the latest lease id will be accepted for those operations. |

## Defining Queues

The first step before tasks can be sent or received is to define a queue. Queues are a resource defined in a Nitric Stack file, such as `nitric.yaml`. At the root level of the stack definition, there can be a `queues` key, which contains and array of queues.

The provider specific implementations for a queue are decided based on the best practices for implementing queue-like behavior in each environment.

> For specific detail on how queues are implemented for each provider see here.

```yaml
queues:
	# Create queues with default options
	my-queue: {}
	my-other-queue: {}
```

<!-- ### Syntax
To define a queue in your Nitric Stack, use the following syntax:

**_YAML_**

```yaml
- name: String
```

**_Properties_**

`name`

Defines the unique name of the queue, used in all future interactions with the queue via Nitric tooling and SDKs.

> **Note:** must contain only letters, numbers and dashes.

_Required:_ Yes

_Type:_ String -->

## Setup Producers

> Coming Soon: Capability to limit queue push capability to a subset of services

## Usage

Using one of the provided Nitric SDKs for your language is the easiest way to work with queues.

### Sending Tasks

Using one of the provided Nitric SDKs for your language is the easiest way to work with queues. First, start by importing the QueueClient.

<CodeExamples
	languages={[
	{
		label: "Node",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	},
	{
		label: "Java",
		value: "java"
	},
	{
		label: "Go",
		value: "go"
	}
	]}
	defaultLang="node"
>
<CodeSnippet snippet="nitrictech/node-sdk/examples/queues/send.ts" />

<CodeSnippet snippet="nitrictech/python-sdk/examples/queues/send.py" />

<CodeSnippet snippet="nitrictech/java-sdk/examples/src/main/java/examples/queues/Send.java" />

<CodeSnippet snippet="nitrictech/go-sdk/examples/queues/send.go" />

</CodeExamples>

### Receiving & Completing Tasks

To process tasks from a queue use a `QueueClient` to `receive` tasks. Since the process is asynchronous, the queue is unaware of whether the task was processed successfully. To ensure failed services don't result in lost tasks, tasks are not removed from a queue when they're received. Instead, tasks are hidden and receivers are granted a temporary `lease` for each task they receive. Once the task is complete, the receiver must make a second call to the queue to `complete` the task, which will remove it from the queue.

<CodeExamples 
	languages={[
	{
		label: "Node",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	},
	{
		label: "Java",
		value: "java"
	},
	{
		label: "Go",
		value: "go"
	}
	]}
	defaultLang="node"
>

<CodeSnippet snippet="nitrictech/node-sdk/examples/queues/receive.ts" />

<CodeSnippet snippet="nitrictech/python-sdk/examples/queues/receive.py" />

<CodeSnippet snippet="nitrictech/java-sdk/examples/src/main/java/examples/queues/Receive.java" />

<CodeSnippet snippet="nitrictech/go-sdk/examples/queues/receive.go" />

</CodeExamples>
