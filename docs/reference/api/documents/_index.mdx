---
title: 'Documents Overview'
---

The Documents service provides applications with the ability to store and retrieve application state.
Nitric provides an expressive Document API to make this process as easy as possible.

The Document service provides a common programming interface across the major Cloud document databases
including AWS DynamoDB, GCP Firestore, Azure CosmosDB, and MongoDB for DigitalOcean.

## Key concepts

Documents are the unit of storage within a collection. They are a lightweight record that contains a set of fields.
Each document is identified by a unique id string.

For example an actor document with the id `robert.downey@mavel.io` might look like this:

```json
📄 robert.downey@nitric.io
{
  "email": "robert.downey@mavel.io",
  "firstName": "Robert",
  "lastName": "Downey",
}
```

Documents can also nest complex JSON objects like maps or arrays.

```json
📄 robert.downey@mavel.io
{
  "email": "robert.downey@mavel.io",
  "firstName": "Robert",
  "lastName": "Downey",
  "born": 1965,
  "active": true,
  "address": {
		"firstLine":  "Unit A",
		"secondLine": "10 Pearls Street",
		"city":       "Boulder",
		"state":      "CO",
		"zipCode":    80302,
	},
	"contactPrefs": [
		"email",
		"sms",
	],
}
```

### Collections

Collections provide containers for documents. In SQL database terms, a collection equates to a table.

With the Documents service, collections are schemaless and each document may contain an arbitary set of fields.
However, it is best practice for collections to have a well defined set of fields.

Continuing our example you could have an `Actors` collection for all your actor documents:

```json
🗂️ Actors [
    📄 robert.downey@mavel.io
    {
     "first": "Robert",
     "last": "Downey Jr"
    }
    📄 scarlett.johansson@mavel.io
    {
     "first": "Scarlett",
     "last": "Johansson"
    }
    📄 benedict.cumberbatch@mavel.io
    {
     "first": "Benedict",
     "last": "Cumberbatch"
    }
]
```

### Stack Definition

To use Collections you need to define them as a resource in a stack file, such as `nitric.yaml`. At the root level of the stack file,
add a collections key, which contains an array of collections.

```yaml
---
collections:
  Actors: {}
```

Collections will be automatically created and configured with sensible defaults by the
Nitric CLI when deploying to a cloud environment and emulated when running and testing locally.

### Subcollections

Subcollections allow you to structure documents hierarchically creating one-to-many parent/child relationships. Subcollections become extremely useful when:

- you have a large number of child items
- your application has different query access patterns
- when you need to optimize performance or cost

Consider the example below:

```json
🗂️ Customers
    📄 apple
    	🗂️ Orders
			📄 tsmc-us-16ffp-77ba4c67d6c1
			📄 tsmc-us-16ffp-e1f7ecdef392
			📄 tsmc-us-16ffp-b56b55d5a2f2
    📄 samsung
    	🗂️ Orders
			📄 tsmc-ko-7ff-0ed0e9dd95ca
			📄 tsmc-ko-7ff-4960179100d6
			📄 tsmc-ko-7ff-b003fb8a3f14
```

Here we have a `Customers` collection with a relatively small number of documents, but each customer has an `Orders` subcollection containing many
thousands of documents. By using separate Customers and Order data we can efficiently retrieve customer records without having to pull all the
associated order data.

Subcollections are also provided with query capabilities, enabling efficient lookups of subcollection documents.

### Notes

- Nitric currently supports 1 level of subcollections under collections
