Nitric Functions are a type of [Service](./overview) that offers a portable way to develop function as a service (FaaS) applications, which may be deployed to Serverless Runtimes such as AWS Lambda and Google CloudRun. This provides a convenient way to write applications based on or including Serverless Functions, with familiar languages like TypeScript, JavaScript, Python, Go, Java, C# and PHP, without concerns for the underlying servers, scaling, runtime software, containerization or deployment.

This development model is analogous to existing function as a service offerings such as AWS Lambda, Azure Functions, Google Cloud Functions and more, without programming to the proprietary interfaces of those platforms. Nitric Functions are built and deployed as Containers, with the [Nitric Membrane](./nitric-membrane) handling i/o standardization to ensure portability across cloud providers or container runtimes.

## Create Functions

Functions are created the same way as [Services](./overview) but use specialized [Templates](./services-templates) for easy scaffolding and maintenance. Before creating a Function, you'll need to install the function template repository:

```bash
nitric templates:repos:add function
```

You can then add a function to your existing application using the `make:service` command, which will guide you through choosing the template and name for your service:

```
nitric make:service
```

## Function Entrypoint

Functions are simple programs that host a server to receive requests and return responses, via the Nitric Membrane.

> see [Service Anatomy](./services#service-anatomy)

The Nitric SDKs provide methods that accept a function and then run that function as a server. Find examples for available SDKs below:

<CodeExamples
	languages={[
	{
		label: "Typescript",
		value: "node"
	},
	{
		label: "Python",
		value: "python"
	},
	{
		label: "Java",
		value: "java"
	},
	{
		label: "Go",
		value: "go"
	},
	{
		label: "C#",
		value: "c-sharp"
	},
	{
		label: "PHP",
		value: "php"
	}
	]}
	defaultLang="node"
>
<CodeExample lang={"node"}>

```typescript
// import the event client library
import { faas } from '@nitric/sdk';

interface HelloWorldRequest {
	greeting?: string;
	name: string;
}

async function handler(request: faas.NitricTrigger<HelloWorldRequest>): Promise<string> {
	const { name, greeting = "Hello" } = request.getObject();

	return `${greeing} ${name}!`;
}

faas.start(handler);
```

</CodeExample>
<CodeExample lang="python">

```python
from nitric.faas import start, Trigger, Response

# Define a handler function which will accept incoming requests (HTTP, Events, etc.) 
# process them and return a `Response`.
def handler(trigger: Trigger) -> Response:
    order = request.get_object()

	// Processing the request...

	// Return a successful response
    return "It worked!"

# Start the handler, this should occur as soon as possible, 
# avoid any lengthy pre-processes or incoming requests could timeout while waiting.
if __name__ == "__main__":
    start(handler)
```

</CodeExample>

<CodeExample lang="java">

```java
package com.example;

import io.nitric.faas.Faas;
import io.nitric.faas.Trigger;
import io.nitric.faas.NitricFunction;
import io.nitric.faas.Response;
import java.util.Map;

public class MyFirstFunction implements NitricFunction {

	@Override
	public Response handle(Trigger trigger) {
		return trigger.buildResponse("Hello World!");
	}

	public static void main(String[] args) {
		Faas.start(new MyFirstFunction());
	}
}
```

</CodeExample>

<CodeExample lang="go">

```go
package main

import (
	"github.com/nitrictech/go-sdk/faas"
)

// NitricFunction - Handles individual function requests (http, events, etc.)
func NitricFunction(request *faas.NitricTrigger) (*faas.NitricResponse, error) {
	// Do something interesting...

	response := trigger.DefaultResponse()

	response.SetData([]byte("Hello World!"))

	return response, nil
}

func main() {
	faas.Start(NitricFunction)
}
```

</CodeExample>

<CodeExample lang="c-sharp">

```csharp
using System;
using Nitric.Faas;
using System.Text;

namespace Nitric.Template.HelloWorld
{
    class HelloWorld : INitricFunction
    {
        public Response Handle(Trigger trigger){
						return trigger.DefaultResponse(
							Encoding.UTF8.GetBytes("Hello World!")
						);
        }
        static void Main(string[] args)
        {
            Faas().start(new HelloWorld());
        }
    }
}
```

</CodeExample>

<CodeExample lang="php">

```php
<?php

namespace App\Function;

use Nitric\V1\Faas\Faas;


$handler = function(Request $request): Response
{
	return "Nitric PHP 8 Template - Success";
}

Faas::start($handler);
```

</CodeExample>

</CodeExamples>

## Function Requests & Responses

Nitric functions provide a request and response model that is completely trigger agnostic. Whether receiving an event from a topic or an HTTP Request, you will always receive the same kind of request object and return the same kind of response object.

The interfaces for each of these are idiomatic to the runtime they were written for, for more information and examples on using them
checkout out our github [repository](https://github.com/nitrictech) for the SDK for your favorite language.

## Running & Triggering Functions

Functions can be configured and tested using the same mechanisms as other [Services](./services#running-services).